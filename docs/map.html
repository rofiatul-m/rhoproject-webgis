<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebGIS Analysis Project</title>

    <link href="https://unpkg.com/maplibre-gl@5.0.1/dist/maplibre-gl.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://unpkg.com/@geoapify/route-directions@^1/styles/styles.min.css" />

    <script src="https://unpkg.com/maplibre-gl@5.0.1/dist/maplibre-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script src="https://unpkg.com/@geoapify/route-directions@^1/dist/index.min.js"></script>

    <style>
        :root {
            --bg: #0f172a;
            --panel: #111827;
            --text: #e5e7eb;
            --muted: #9ca3af;
            --accent: #60a5fa;
            --chip: #1f2937;
            --navbar-text-color: #111827;
            /*Warna gelap untuk basemap terang*/
        }

        .dark-basemap {
            --navbar-text-color: #e5e7eb;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", Helvetica, Arial;
            background: linear-gradient(180deg, #0b1021 0%, var(--bg) 100%);
            color: var(--text);
            height: 100vh;
        }

        #map {
            height: 100%;
            width: 100%;
            position: relative;
        }

        /* Navbar */
        nav {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            z-index: 20;
            display: flex;
            align-items: center;
            padding: 0 16px;
            background: transparent;
            border-bottom: none;
            box-shadow: none;
        }

        nav .left a {
            font-size: 1.25rem;
            color: var(--navbar-text-color);
            font-weight: 600;
            text-decoration: none;
            letter-spacing: 1px;
        }

        /* --- Panel Gabungan (Controls + Chart) - HORIZONTAL --- */
        .combined-panel {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: rgba(17, 24, 39, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 10px 12px;
            color: var(--text);
            font-size: 12px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }

        .panel-header {
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .switch-toggle {
            position: relative;
            width: 38px;
            height: 20px;
            background-color: var(--muted);
            border-radius: 999px;
            border: none;
            cursor: pointer;
            padding: 0;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }

        .switch-toggle[aria-pressed="true"] {
            background-color: #34d399;
        }

        .switch-slider {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            border-radius: 50%;
            transition: transform 0.2s ease, left 0.2s ease;
        }

        .switch-toggle[aria-pressed="true"] .switch-slider {
            transform: translateX(18px);
        }

        .panel-toggle-btn {
            cursor: pointer;
            padding: 2px 6px;
            background: var(--chip);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            transition: 0.2s;
            color: var(--text);
            font-weight: normal;
        }

        .panel-toggle-btn:hover {
            background: rgba(17, 24, 39, 0.85);
        }

        .panel-content {
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }

        .controls-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-right: 15px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 350px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .ranges-control {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 6px;
        }

        .ranges-label {
            font-size: 12px;
            color: var(--muted);
            white-space: nowrap;
            margin-bottom: 0;
            padding: 0;
        }

        /* Chart Section*/
        .chart-section {
            min-width: 300px;
            max-width: 300px;
        }

        .chart-title {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 8px;
            margin-top: 0;
            color: var(--accent);
        }

        .control-group {
            display: grid;
            gap: 6px;
            min-width: 100px;
        }

        .control-group label {
            font-size: 12px;
            color: var(--muted);
            white-space: nowrap;
        }

        /* Container untuk Network Chart (Elevasi) dan Stats */
        #network-chart-wrapper {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .route-stats-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding-top: 0;
            border-top: none;
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .stat {
            text-align: left;
        }

        .stat .label {
            display: block;
            font-size: 11px;
            color: var(--muted);
            margin-bottom: 2px;
        }

        .stat span:last-child {
            font-size: 13px;
            font-weight: 600;
            color: var(--accent);
        }

        .elevation-chart-container {
            height: 120px;
            width: 100%;
            margin-top: 0;
        }

        .hidden {
            display: none !important;
        }

        #route-directions .route-directions-input-row,
        #route-directions .route-directions-input-row input,
        #route-directions .route-directions-input-row .geoapify-autocomplete-container {
            width: 100% !important;
        }

        #route-directions input[type="text"] {
            background: var(--panel) !important;
            color: var(--text) !important;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 8px 10px;
            font-size: 12px;
            height: 40px;
        }

        #route-directions .geoapify-autocomplete-container {
            flex-grow: 1;
            width: 100%;
        }

        #route-directions button {
            background: var(--chip);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text);
            border-radius: 6px;
            padding: 6px;
            width: 32px;
            height: 32px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #route-directions button:hover {
            background: var(--accent);
            color: var(--bg);
        }

        #route-directions svg {
            fill: currentColor;
            width: 16px;
            height: 16px;
        }

        #route-directions .route-directions-input-row {
            padding: 0;
            gap: 8px;
            margin-bottom: 8px;
        }

        #route-directions .route-directions-input-row>div:first-child {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
        }

        .geoapify-autocomplete-items {
            background: var(--panel);
            border: 1px solid var(--accent);
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .geoapify-autocomplete-item {
            color: var(--text);
            padding: 8px 10px;
        }

        .geoapify-autocomplete-item:hover,
        .geoapify-autocomplete-item-active {
            background: rgba(96, 165, 250, 0.2);
        }

        #route-directions .route-directions-calculate-button {
            background: #34d399;
            color: var(--bg);
            border: none;
            font-weight: bold;
            height: 40px;
            border-radius: 10px;
            padding: 8px 15px;
        }

        #route-directions .route-directions-calculate-button:hover {
            background: #10b981;
        }

        .legend {
            position: absolute;
            top: 50px;
            left: 16px;
            background: rgba(17, 24, 39, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 10px 12px;
            font-size: 12px;
            color: var(--muted);
            max-width: 280px;
            line-height: 1.3;
            z-index: 10;
        }

        .legend>div:first-child {
            font-weight: bold;
            color: var(--text);
        }

        .maplibregl-ctrl-top-right {
            margin-top: 50px;
        }

        input,
        select,
        button,
        textarea {
            width: 100%;
            background: var(--panel);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 8px 10px;
            outline: none;
            font-size: 12px;
        }

        input:focus,
        select:focus,
        textarea:focus {
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.2);
        }

        .chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 999px;
            background: var(--chip);
            border: 1px solid rgba(255, 255, 255, 0.08);
            font-size: 12px;
        }

        .chip.clickable {
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .chip[data-active="true"] {
            background: var(--chip);
            color: var(--text);
            border-color: rgba(255, 255, 255, 0.08);
        }

        .chip[data-active="false"] {
            opacity: 0.6;
        }

        .chip[data-active="true"] {
            opacity: 1;
        }

        .row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .footer-note {
            color: var(--muted);
            font-size: 12px;
        }

        .toggle-group {
            display: flex;
            flex-direction: row;
            gap: 6px;
        }

        .toggle {
            padding: 6px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: var(--chip);
            color: var(--text);
            cursor: pointer;
            font-size: 12px;
            user-select: none;
        }

        .toggle[aria-pressed="true"],
        .toggle.active {
            background: var(--accent);
            color: #0b1021;
            border-color: transparent;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text);
            cursor: pointer;
            user-select: none;
        }

        .radio-option input[type="radio"] {
            width: auto;
            height: 14px;
            margin: 0;
            accent-color: var(--accent);
            padding: 0;
            border: none;
            background: none;
            cursor: pointer;
        }

        /* Basemap Switcher */
        #basemapSwitcher {
            position: absolute;
            bottom: 40px;
            right: 16px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.05);
            z-index: 10;
            overflow: hidden;
            cursor: pointer;
            transition: all 300ms ease;
        }

        #activeBasemap {
            padding: 8px 12px;
            font-size: 0.875rem;
            font-weight: 600;
            color: white;
            background-color: #f59e0b;
            border-radius: 8px;
        }

        #optionsContainer {
            display: none;
            flex-direction: column;
            background-color: white;
            border: 1px solid #e5e7eb;
            margin-top: 4px;
            border-radius: 8px;
            overflow: hidden;
        }

        #optionsContainer.show {
            display: flex;
        }

        /* Basemap Options */
        #optionsContainer>div {
            padding: 8px 12px;
            font-size: 0.875rem;
            cursor: pointer;
            border-bottom: 1px solid #e5e7eb;
            color: #4b5563;
            transition: background-color 150ms ease;
        }

        #optionsContainer>div:last-child {
            border-bottom: 0;
        }

        #optionsContainer>div:hover {
            background-color: #f3f4f6;
        }
    </style>
</head>

<body class="dark-basemap">
    <nav>
        <div class="left">
            <a href="index.html">RHO PROJECT</a>
        </div>
    </nav>

    <div id="map"></div>

    <div class="legend" id="legend">
        <div style="margin-bottom:6px">Legend</div>
        <div id="legendItems" class="row"></div>
    </div>

    <div id="combined-panel" class="combined-panel">
        <div class="panel-header">
            <span style="display:flex; align-items:center; gap:6px; margin-right: 15px;">
                <span>Analysis</span>
                <button id="analysisToggle" class="switch-toggle" aria-pressed="false">
                    <span class="switch-slider"></span>
                </button>
            </span>
            <span id="panel-toggle" class="panel-toggle-btn">Hide</span>
        </div>


        <div id="panel-content" class="panel-content">

            <div id="controls-section" class="controls-section">
                <div class="control-group"
                    style="margin-bottom: 12px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); padding-bottom: 10px;">
                    <label style="font-weight: bold; color: var(--text);">Analysis Type</label>
                    <div class="row" style="gap: 15px; margin-top: 4px;">
                        <label class="radio-option">
                            <input type="radio" name="analysisType" value="isoline" checked />
                            Isoline
                        </label>
                        <label class="radio-option">
                            <input type="radio" name="analysisType" value="network" />
                            Network/Route
                        </label>
                    </div>
                </div>
                <div class="controls" id="isoline-controls">
                    <div class="control-row">
                        <div class="control-group">
                            <label for="mode">Travel mode</label>
                            <select id="mode">
                                <option value="drive">car</option>
                                <option value="motorcycle">motorcycle</option>
                                <option value="bicycle">bicycle</option>
                                <option value="walk">walk</option>
                                <option value="light_truck">light_truck</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="type">Type</label>
                            <select id="type">
                                <option value="time">time</option>
                                <option value="distance">distance</option>
                            </select>
                        </div>
                    </div>

                    <div class="ranges-control">
                        <span class="ranges-label">Ranges (min/km)</span>
                        <div id="rangesToggle" class="toggle-group"></div>
                    </div>
                </div>

                <div id="route-directions-wrapper" style="width: 100%; display: none;">
                    <div id="route-directions" style="width: 100%;"></div>
                </div>

                <div class="footer-note" id="footer-note">Tip: click on the map to set a new center point.</div>
            </div>

            <div id="chart-section" class="chart-section">
                <div id="isoline-chart-wrapper">
                    <div class="chart-title">Shelter Coverage</div>
                    <canvas id="shelterChart" width="300" height="200"></canvas>
                </div>

                <div id="network-chart-wrapper" class="hidden">
                    <div class="route-stats-section" id="route-stats">
                        <div class="stats-row">
                            <div class="stat">
                                <span class="label">Distance:</span>
                                <span id="distance">-</span>
                            </div>
                            <div class="stat">
                                <span class="label">Duration:</span>
                                <span id="duration">-</span>
                            </div>
                        </div>
                        <div class="stats-row">
                            <div class="stat">
                                <span class="label">Elev. Gain:</span>
                                <span id="elevation-gain">-</span>
                            </div>
                            <div class="stat">
                                <span class="label">Elev. Loss:</span>
                                <span id="elevation-loss">-</span>
                            </div>
                        </div>
                    </div>

                    <div class="chart-title" style="margin-top: 5px;">Elevation Profile</div>
                    <div class="elevation-chart-container">
                        <canvas id="chart-elevation" width="300" height="120"></canvas>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <div id="basemapSwitcher">
        <div id="activeBasemap">
            Dark
        </div>
        <div id="optionsContainer">
        </div>
    </div>

    <script>
        Chart.register(
            Chart.LineElement,
            Chart.LineController,
            Chart.Legend,
            Chart.Tooltip,
            Chart.LinearScale,
            Chart.PointElement,
            Chart.Filler,
            Chart.Title
        );

        // =================================================================
        // KONFIGURASI
        // =================================================================
        const yourAPIKey = "f82ea38cb77543d59c597faaa263e714";

        const initialCenter = [116.10255, -8.40401]; // Lombok Utara (lng, lat)
        const initialZoom = 10;

        const RANGES_PRESETS = {
            time: [5, 10, 15, 20, 30],
            distance: [1, 3, 5, 10, 20]
        };

        const els = {
            mode: document.getElementById("mode"),
            type: document.getElementById("type"),
            rangesToggle: document.getElementById("rangesToggle"),
            legendItems: document.getElementById("legendItems"),
            shelterChart: document.getElementById('shelterChart'),
            analysisToggle: document.getElementById("analysisToggle"),
            chartSection: document.getElementById("chart-section"),
            isolineControls: document.getElementById("isoline-controls"),
            routeDirectionsWrapper: document.getElementById("route-directions-wrapper"),
            analysisTypeInputs: document.querySelectorAll('input[name="analysisType"]'),
            footerNote: document.getElementById('footer-note'),
            routeDirectionsContainer: document.getElementById('route-directions'),
            routeStats: document.getElementById('route-stats'),
            isolineChartWrapper: document.getElementById('isoline-chart-wrapper'),
            networkChartWrapper: document.getElementById('network-chart-wrapper'),
        };

        // State global
        let analysisActive = false;
        let shelterVisible = true;
        let shelterChart = null;
        let currentIsolineData = null;
        let activeAnalysisType = 'isoline';
        let routeChartInstance;
        let routeWaypoints = [];
        let routeMarkers = []

        const isolineData = {
            lat: initialCenter[1],
            lon: initialCenter[0],
            mode: "drive",
            type: "time",
            ranges: new Set()
        };

        // Inisialisasi inputs & tampilan awal
        els.mode.value = isolineData.mode;
        els.type.value = isolineData.type;
        els.analysisToggle.setAttribute("aria-pressed", analysisActive ? "true" : "false");
        els.chartSection.style.display = "none";

        // Inisialisasi awal wrapper rute
        els.routeDirectionsWrapper.style.display = 'none';

        // =================================================================
        // DATA SHELTER
        // =================================================================
        const SHELTER_DATA_URL = 'https://geoserver.mapid.io/layers_new/get_layer?api_key=d394dc425f0e41008a52ef3923d68925&layer_id=691ddd753afc1f9f72436cc3&project_id=691d3f2f65f912e9a2d92a8d';

        let shelterPoints = turf.featureCollection([]); 

        async function loadShelterData() {
            try {
                const response = await fetch(SHELTER_DATA_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const data = await response.json();

                shelterPoints = data;
                console.log("Data shelter berhasil dimuat:", shelterPoints.features.length, "titik.");

                if (typeof map !== 'undefined' && map.loaded()) {
                    const source = map.getSource('shelter-points-source');
                    if (source) {
                        source.setData(shelterPoints);
                    }
                }

            } catch (error) {
                console.error("Gagal memuat data shelter dari URL:", error);
            }
        }

        loadShelterData();

        // Map Setup
        const basemaps = {
            "Basic": `https://maps.geoapify.com/v1/styles/klokantech-basic/style.json?apiKey=${yourAPIKey}`,
            "Dark": `https://maps.geoapify.com/v1/styles/dark-matter-purple-roads/style.json?apiKey=${yourAPIKey}`,
            "3D": `https://maps.geoapify.com/v1/styles/maptiler-3d/style.json?apiKey=${yourAPIKey}`,
        };

        let activeBasemap = "Dark";
        const defaultStyle = basemaps[activeBasemap];

        // --- Initial Navbar Color Adjustment ---
        if (activeBasemap === "Dark") {
            document.body.classList.add("dark-basemap");
        } else {
            document.body.classList.remove("dark-basemap");
        } // --- Initial Navbar Color Adjustment ---

        const map = new maplibregl.Map({
            container: "map",
            style: defaultStyle,
            center: initialCenter,
            zoom: initialZoom
        });

        map.addControl(new maplibregl.NavigationControl({ showCompass: true }), "top-right");
        map.addControl(new maplibregl.GeolocateControl({
            positionOptions: { enableHighAccuracy: true },
            trackUserLocation: false,
            showAccuracyCircle: true
        }), "top-right");

        // Center marker (Isoline)
        const markerEl = document.createElement("div");
        markerEl.style.cssText = "width:14px;height:14px;border-radius:50%;background:#60a5fa;border:2px solid white;box-shadow:0 0 0 2px rgba(96,165,250,.35)";
        const centerMarker = new maplibregl.Marker({ element: markerEl, draggable: true })
            .setLngLat([isolineData.lon, isolineData.lat]);

        centerMarker.on("dragend", () => {
            if (!analysisActive || activeAnalysisType !== 'isoline') return;
            const { lng, lat } = centerMarker.getLngLat();
            isolineData.lat = lat;
            isolineData.lon = lng;
            getIsoline();
        });


        // =================================================================
        // Route Directions & Chart Elevation Functions
        // =================================================================

        function formatDistance(meters) {
            if (meters >= 1000) {
                return (meters / 1000).toFixed(1) + ' km';
            }
            return Math.round(meters) + ' m';
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);

            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            }
            return `${minutes}m`;
        }

        function formatElevation(meters) {
            return Math.round(meters) + ' m';
        }

        function calculateElevationStats(elevationData) {
            let gain = 0;
            let loss = 0;

            for (let i = 1; i < elevationData.length; i++) {
                const diff = elevationData[i] - elevationData[i - 1];
                if (diff > 0) {
                    gain += diff;
                } else {
                    loss += Math.abs(diff);
                }
            }

            return { gain, loss };
        }

        function calculateElevationProfileData(feature) {
            const legs = feature.properties.legs || [];
            const labels = [];
            const data = [];

            let totalDistance = 0;

            legs.forEach((leg) => {
                if (leg.elevation_range) {
                    leg.elevation_range.forEach(([distance, elevation]) => {
                        labels.push(totalDistance + distance);
                        data.push(elevation);
                    });
                    totalDistance += leg.distance;
                }
            });

            // Optimize data for performance
            const optimizedLabels = [];
            const optimizedData = [];
            const minDist = 50; // 50m
            const minHeight = 5; // 5m

            labels.forEach((dist, index) => {
                if (index === 0 || index === labels.length - 1 ||
                    (optimizedLabels.length > 0 && (dist - optimizedLabels[optimizedLabels.length - 1]) > minDist) ||
                    (optimizedData.length > 0 && Math.abs(data[index] - optimizedData[optimizedData.length - 1]) > minHeight)) {
                    optimizedLabels.push(dist);
                    optimizedData.push(data[index]);
                }
            });

            return {
                labels: optimizedLabels,
                data: optimizedData,
                rawData: data
            };
        }


        function destroyRouteChart() {
            if (routeChartInstance) {
                routeChartInstance.destroy();
                routeChartInstance = null;
            }
        }

        function updateRouteStats(feature, elevationData) {
            const properties = feature.properties;
            const distance = properties.distance || 0;
            const time = properties.time || 0;

            const elevationStats = calculateElevationStats(elevationData.rawData);

            document.getElementById('distance').textContent = formatDistance(distance);
            document.getElementById('duration').textContent = formatDuration(time);
            document.getElementById('elevation-gain').textContent = formatElevation(elevationStats.gain);
            document.getElementById('elevation-loss').textContent = formatElevation(elevationStats.loss);
            els.networkChartWrapper.classList.remove('hidden');
        }

        function clearRouteStatsAndChart() {
            els.networkChartWrapper.classList.add('hidden');
            destroyRouteChart();

            document.getElementById('distance').textContent = '-';
            document.getElementById('duration').textContent = '-';
            document.getElementById('elevation-gain').textContent = '-';
            document.getElementById('elevation-loss').textContent = '-';
        }

        function drawElevationProfile(elevationData) {
            destroyRouteChart();

            const canvas = document.getElementById('chart-elevation');
            const ctx = canvas.getContext('2d');

            const chartData = {
                labels: elevationData.labels,
                datasets: [{
                    data: elevationData.data,
                    fill: true,
                    borderColor: '#60a5fa',
                    backgroundColor: 'rgba(96, 165, 250, 0.1)',
                    tension: 0.1,
                    pointRadius: 0,
                    spanGaps: true
                }]
            };

            const cssTextColor = (getComputedStyle(document.documentElement).getPropertyValue('--text') || '#e5e7eb').trim();
            const cssMutedColor = (getComputedStyle(document.documentElement).getPropertyValue('--muted') || '#9ca3af').trim();

            const config = {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Distance (m)',
                                color: cssMutedColor,
                                font: { size: 10 }
                            },
                            ticks: {
                                color: cssTextColor,
                                font: { size: 9 },
                                callback: function (value) { return formatDistance(value); }
                            },
                            grid: { color: 'rgba(255, 255, 255, 0.05)' }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Elevation (m)',
                                color: cssMutedColor,
                                font: { size: 10 }
                            },
                            ticks: {
                                color: cssTextColor,
                                font: { size: 9 }
                            },
                            grid: { color: 'rgba(255, 255, 255, 0.05)' }
                        }
                    },
                    plugins: {
                        title: { display: false },
                        legend: { display: false },
                        tooltip: {
                            displayColors: false,
                            callbacks: {
                                title: (tooltipItems) => {
                                    return "Distance: " + formatDistance(tooltipItems[0].label);
                                },
                                label: (tooltipItem) => {
                                    return "Elevation: " + Math.round(tooltipItem.raw) + 'm';
                                },
                            },
                            bodyFont: { size: 10 },
                            titleFont: { size: 10 }
                        }
                    }
                }
            };

            routeChartInstance = new Chart(ctx, config);
        }

        function createElevationChart(routeData) {
            if (!routeData) {
                return;
            }

            let feature;

            if (routeData.type === 'Feature') {
                feature = routeData;
            } else if (routeData.type === 'FeatureCollection' && routeData.features && routeData.features.length > 0) {
                feature = routeData.features[0];
            } else {
                console.error('Unexpected route data format for elevation chart:', routeData);
                return;
            }

            const elevationData = calculateElevationProfileData(feature);

            if (elevationData.data.length === 0) {
                clearRouteStatsAndChart();
                return;
            }

            drawElevationProfile(elevationData);
            updateRouteStats(feature, elevationData);
        }

        function visualizeRoute(routeData) {
            let geoJsonData;
            let routeFeature;

            if (routeData.type === 'Feature') {
                geoJsonData = {
                    type: 'FeatureCollection',
                    features: [routeData]
                };
                routeFeature = routeData;
            } else if (routeData.type === 'FeatureCollection' && routeData.features && routeData.features.length > 0) {
                geoJsonData = routeData;
                routeFeature = routeData.features[0];
            } else {
                console.error('Unexpected route data format:', routeData);
                return;
            }

            if (map.getSource('network-route-source')) {
                map.getSource('network-route-source').setData(geoJsonData);
            }

            if (routeFeature && routeFeature.geometry && routeFeature.geometry.coordinates) {
                const coordinates = routeFeature.geometry.coordinates;
                const bounds = new maplibregl.LngLatBounds();

                const processCoords = (coords) => {
                    for (const coord of coords) {
                        if (typeof coord[0] === 'number') {
                            bounds.extend(coord);
                        } else {
                            processCoords(coord);
                        }
                    }
                };

                if (routeFeature.geometry.type === 'MultiLineString') {
                    coordinates.forEach(processCoords);
                } else {
                    processCoords(coordinates);
                }

                routeWaypoints.forEach(waypoint => {
                    bounds.extend([waypoint[0], waypoint[1]]);
                });

                map.fitBounds(bounds, {
                    padding: {
                        top: 50,
                        bottom: 250,
                        left: 50,
                        right: 50
                    },
                    duration: 1000
                });
            }
        }

        function clearRouteVisualization() {
            if (map.getSource('network-route-source')) {
                map.getSource('network-route-source').setData({
                    type: 'FeatureCollection',
                    features: []
                });
            }

            clearRouteStatsAndChart();
        }

        function updateRouteMarkers() {
            clearRouteMarkers();

            routeWaypoints.forEach((waypoint, index) => {
                const marker = new maplibregl.Marker({
                    color: index === 0 ? '#34d399' : (index === routeWaypoints.length - 1 ? '#ef4444' : '#f59e0b')
                })
                    .setLngLat([waypoint[0], waypoint[1]])
                    .addTo(map);

                routeMarkers.push(marker);
            });
        }

        function clearRouteMarkers() {
            routeMarkers.forEach(marker => marker.remove());
            routeMarkers = [];
        }


        // =================================================================
        // Inisialisasi RouteDirections
        // =================================================================
        const routeDirections = new directions.RouteDirections(els.routeDirectionsContainer, yourAPIKey, {
            supportedModes: ['walk', 'motorcycle', 'drive', 'light_truck', 'bus'],
            elevation: true,
            noStopover: false
        }, {
            placeholder: "Enter location or click on the map"
        });

        // Listener RouteDirections
        routeDirections.on('waypointChanged', () => {
            const options = routeDirections.getOptions();
            const componentWaypoints = options.waypoints.filter(w => w.lat && w.lon);
            routeWaypoints = componentWaypoints.map(w => [w.lon, w.lat]);

            if (routeWaypoints.length < 2) {
                clearRouteVisualization();
                clearRouteMarkers();
            }
            if (routeWaypoints.length > 0) {
                updateRouteMarkers();
            }
        });

        routeDirections.on('routeCalculated', (geojson) => {
            if (activeAnalysisType === 'network' && analysisActive) {
                visualizeRoute(geojson);
                createElevationChart(geojson);
            }
        });

        routeDirections.on('routeError', (error) => {
            console.error("Route calculation error:", error);
            clearRouteVisualization();
        });

        // =================================================================
        // Map Click Listener
        // =================================================================
        map.on("click", (e) => {
            const { lng, lat } = e.lngLat;

            if (activeAnalysisType === 'network' && analysisActive) {
                // Tambahkan waypoint (Network Analysis)
                routeDirections.addLocation(lat, lng);
            } else if (activeAnalysisType === 'isoline' && analysisActive) {
                // Logic Isoline
                isolineData.lat = lat;
                isolineData.lon = lng;
                centerMarker.setLngLat([lng, lat]);
                getIsoline();
            }
        });

        // =================================================================
        // Fungsi untuk switch analisis
        // =================================================================
        function switchAnalysisType(type) {
            activeAnalysisType = type;

            if (type === 'isoline') {
                els.isolineControls.style.display = 'flex';
                els.routeDirectionsWrapper.style.display = 'none';
                els.footerNote.textContent = "Tip: click on the map to set a new center point.";

                // Sembunyikan chart network, tampilkan chart isoline (jika aktif)
                els.networkChartWrapper.classList.add('hidden');
                els.isolineChartWrapper.classList.remove('hidden');
                if (analysisActive) els.chartSection.style.display = 'block';

                clearRouteVisualization();
                clearRouteMarkers();

                if (analysisActive) {
                    centerMarker.addTo(map);
                    getIsoline();
                } else {
                    clearIsolines();
                }

            } else if (type === 'network') {
                els.isolineControls.style.display = 'none';
                els.routeDirectionsWrapper.style.display = 'block'; // Perubahan: Kontrol rute ditampilkan
                els.footerNote.textContent = "Tip: click on the map to set start and end points.";

                // Sembunyikan chart isoline, chart network akan ditampilkan saat rute dihitung
                els.isolineChartWrapper.classList.add('hidden');
                // els.networkChartWrapper.classList.add('hidden'); // Akan disembunyikan/ditampilkan di clear/updateRouteStats
                if (analysisActive) els.chartSection.style.display = 'block';

                clearIsolines();
                centerMarker.remove();

                if (analysisActive) {
                    // Hanya visualisasi jika sudah ada waypoint
                    //routeDirections.calculate();
                    updateRouteMarkers();
                } else {
                    clearRouteVisualization();
                }
            }

            // --- Bagian yang diubah: Update Legenda ---
            els.legendItems.innerHTML = "";
            if (activeAnalysisType === 'isoline') {
                renderBaseLegendItems(analysisActive); // Menampilkan Isoline & Shelter (jika aktif)
            } else if (activeAnalysisType === 'network') {
                renderBaseLegendItems(false); // Hanya tampilkan shelter, tanpa "Reachable Shelters"
                renderRouteLegendItems(analysisActive); // Tambahkan legenda rute jika aktif
            }
            updateShelterLayerVisibility();
        }

        // Listener untuk radio buttons
        els.analysisTypeInputs.forEach(radio => {
            radio.addEventListener('change', (e) => {
                switchAnalysisType(e.target.value);
            });
        });

        // ===== Range toggles, Mode, Type Listeners =====
        function renderRangeToggles() {
            const type = els.type.value;
            const values = RANGES_PRESETS[type];
            els.rangesToggle.innerHTML = "";

            isolineData.ranges = new Set(values.slice(0, 3)); // Default 3 pertama

            values.forEach((v) => {
                const btn = document.createElement("button");
                btn.className = "toggle";
                btn.type = "button";
                btn.dataset.value = String(v);
                const unit = type === "time" ? "min" : "km";
                btn.textContent = `${v} ${unit}`;

                if (isolineData.ranges.has(v)) {
                    btn.classList.add("active");
                    btn.setAttribute("aria-pressed", "true");
                } else {
                    btn.setAttribute("aria-pressed", "false");
                }

                btn.addEventListener("click", () => {
                    const num = parseInt(btn.dataset.value, 10);
                    if (isolineData.ranges.has(num)) {
                        isolineData.ranges.delete(num);
                        btn.setAttribute("aria-pressed", "false");
                        btn.classList.remove("active");
                    } else {
                        isolineData.ranges.add(num);
                        btn.setAttribute("aria-pressed", "true");
                        btn.classList.add("active");
                    }
                    if (analysisActive && activeAnalysisType === 'isoline') getIsoline();
                });
                els.rangesToggle.appendChild(btn);
            });

            if (analysisActive && activeAnalysisType === 'isoline') getIsoline();
        }

        renderRangeToggles();

        els.type.addEventListener("change", () => {
            isolineData.type = els.type.value;
            renderRangeToggles();
        });

        els.mode.addEventListener("change", () => {
            isolineData.mode = els.mode.value;
            if (analysisActive && activeAnalysisType === 'isoline') getIsoline();
        });

        // Helpers
        function colorForIndex(i, total) {
            // Menghasilkan warna berdasarkan HSL untuk visualisasi rentang
            const hue = Math.round((i / Math.max(total, 1)) * 300);
            return `hsl(${hue}, 85%, 60%)`;
        }

        async function fetchIsoline(lat, lon, type, mode, rangeParam) {
            const p = new URLSearchParams({
                lat,
                lon,
                type,
                mode,
                range: rangeParam,
                apiKey: yourAPIKey
            });

            const res = await fetch(`https://api.geoapify.com/v1/isoline?${p.toString()}`);
            if (!res.ok) throw new Error(`HTTP ${res.status} â€” ${res.statusText}`);
            return res.json();
        }

        function clearIsolines() {
            const style = map.getStyle();
            if (style && Array.isArray(style.layers)) {
                style.layers.map(l => l.id).forEach((id) => {
                    try {
                        if (id.startsWith("isoline-fill-") || id.startsWith("isoline-line-")) {
                            if (map.getLayer(id)) map.removeLayer(id);
                        }
                    } catch (e) { /* ignore */ }
                });
            }

            if (map.getLayer('reachable-shelters')) map.removeLayer('reachable-shelters');
            if (map.getSource('reachable-shelters-src')) map.removeSource('reachable-shelters-src');

            if (map.getSource('isoline-multi')) {
                try { map.removeSource('isoline-multi'); } catch (e) { /* ignore */ }
            }
        }

        function addLegendItem(label, color, isClickable = false) {
            const el = document.createElement("span");
            el.className = "chip";
            if (isClickable) {
                el.classList.add('clickable');
            }
            // Menggunakan div untuk warna marker rute (shape kotak)
            let colorElement;
            if (label.includes("Point")) {
                // Untuk marker, gunakan bentuk kotak/lingkaran padat yang lebih jelas
                colorElement = `<span style="width:10px;height:10px;border-radius:50%;background:${color};display:inline-block;margin-right:6px"></span>`;
            } else if (label.includes("Route")) {
                // Untuk rute, gunakan garis
                colorElement = `<span style="width:18px;height:2px;background:${color};display:inline-block;margin-right:6px"></span>`;
            }
            else {
                // Default: lingkaran
                colorElement = `<span style="width:10px;height:10px;border-radius:50%;background:${color};display:inline-block;margin-right:6px"></span>`;
            }

            el.innerHTML = colorElement + label;
            els.legendItems.appendChild(el);
            return el;
        }

        function updateShelterLayerVisibility() {
            const visibility = shelterVisible ? 'visible' : 'none';
            if (map.loaded()) {
                if (map.getLayer('all-shelters-bg')) {
                    map.setLayoutProperty('all-shelters-bg', 'visibility', visibility);
                }
                if (map.getLayer('reachable-shelters')) {
                    map.setLayoutProperty('reachable-shelters', 'visibility', visibility);
                }
            }
        }

        function renderBaseLegendItems(showReachable = false) {
            // Warna shelter biasa (Grey)
            const shelterChip = addLegendItem('Shelter', '#4a4a4a', true);

            shelterChip.setAttribute('data-active', shelterVisible ? 'true' : 'false');

            shelterChip.addEventListener('click', () => {
                shelterVisible = !shelterVisible;
                shelterChip.setAttribute('data-active', shelterVisible ? 'true' : 'false');
                updateShelterLayerVisibility();

                const reachableChips = els.legendItems.querySelectorAll('[data-layer-id="reachable-shelters"]');
                reachableChips.forEach(chip => {
                    chip.setAttribute('data-active', shelterVisible ? 'true' : 'false');
                });
            });

            // Hanya tampilkan 'Reachable Shelters' jika mode Isoline sedang aktif
            if (showReachable) {
                // Warna reachable shelter (Red)
                const reachableChip = addLegendItem('Reachable Shelters', '#ff0000', false);
                reachableChip.dataset.layerId = 'reachable-shelters';
                reachableChip.setAttribute('data-active', shelterVisible ? 'true' : 'false');
            }
        }

        // =================================================================
        // Fungsi untuk Legenda Rute
        // =================================================================
        function renderRouteLegendItems(routeActive) {
            if (!routeActive) return; // Route legend hanya tampil jika analisis rute aktif

            const routeColor = '#60a5fa';

            const routeChip = addLegendItem('Route', routeColor, false);
            routeChip.dataset.layerId = 'network-route-layer';

            // Marker Rute (Start, Stopover, End)
            addLegendItem('Start Point', '#34d399', false);
            addLegendItem('Stopover', '#f59e0b', false);
            addLegendItem('End Point', '#ef4444', false);
        }


        function fitToGeoJSON(geo) {
            const b = new maplibregl.LngLatBounds();
            function extend(coords) {
                for (const c of coords) {
                    if (typeof c[0] === "number") b.extend(c);
                    else extend(c);
                }
            }
            if (!geo) return;
            if (geo.type === "FeatureCollection")
                geo.features.forEach((f) => extend(f.geometry.coordinates));
            else if (geo.type === "Feature") extend(f.geometry.coordinates);
            else extend(geo.coordinates);

            // Tambahkan center marker isoline ke bounds jika aktif
            if (activeAnalysisType === 'isoline' && analysisActive && centerMarker.getLngLat()) {
                const { lng, lat } = centerMarker.getLngLat();
                b.extend([lng, lat]);
            }

            if (!b.isEmpty()) map.fitBounds(b, { padding: 50 });
        }

        // =================================================================
        // ANALISIS SHELTER 
        // =================================================================
        function analyzeShelters(isolineGeoJSON, isolineColors) {
            const results = {};
            const ranges = [...isolineData.ranges].sort((a, b) => a - b);

            const chartColors = {};

            const isolineFeatures = (isolineGeoJSON.features || [])
                .map(f => ({
                    ...f,
                    properties: {
                        ...f.properties,
                        rangeValue: f.properties.range || f.properties.metric || 0,
                        // Menghitung label dalam menit atau kilometer
                        displayRange: isolineData.type === 'time' ? `${Math.round((f.properties.range || 0) / 60)} min` : `${Math.round((f.properties.range || 0) / 1000)} km`
                    }
                }))
                .sort((a, b) => a.properties.rangeValue - b.properties.rangeValue);

            const cumulativeReachable = {};

            isolineFeatures.forEach((feature, i) => {
                const rangeLabel = feature.properties.displayRange;
                chartColors[rangeLabel] = isolineColors[rangeLabel];

                const polygonFeature = feature;
                let pointsInPolygon;
                try {
                    pointsInPolygon = turf.pointsWithinPolygon(shelterPoints, polygonFeature);
                } catch (e) {
                    pointsInPolygon = turf.featureCollection([]);
                }

                cumulativeReachable[rangeLabel] = pointsInPolygon.features.length;

                const prevRangeLabel = i > 0 ? isolineFeatures[i - 1].properties.displayRange : null;
                const prevCount = prevRangeLabel ? cumulativeReachable[prevRangeLabel] : 0;

                results[rangeLabel] = cumulativeReachable[rangeLabel] - prevCount;
            });

            // Build a MultiPolygon that contains all polygons
            const allPolyCoords = [];
            isolineFeatures.forEach(f => {
                if (!f.geometry) return;
                if (f.geometry.type === 'Polygon') {
                    allPolyCoords.push(f.geometry.coordinates);
                } else if (f.geometry.type === 'MultiPolygon') {
                    f.geometry.coordinates.forEach(mp => allPolyCoords.push(mp));
                }
            });

            let allReachableShelters = turf.featureCollection([]);
            if (allPolyCoords.length > 0) {
                const multi = turf.multiPolygon(allPolyCoords);
                try {
                    allReachableShelters = turf.pointsWithinPolygon(shelterPoints, multi);
                } catch (e) {
                    allReachableShelters = turf.featureCollection([]);
                }
            }

            updateShelterMapLayer(allReachableShelters);
            updateChart(results, chartColors);
        }


        // =================================================================
        // UPDATE SHELTER LAYER
        // =================================================================
        function updateShelterMapLayer(reachableShelters) {
            const srcId = 'reachable-shelters-src';
            const layerId = 'reachable-shelters';

            if (map.getLayer(layerId)) map.removeLayer(layerId);
            if (map.getSource(srcId)) map.removeSource(srcId);

            map.addSource(srcId, {
                type: 'geojson',
                data: reachableShelters
            });

            map.addLayer({
                id: layerId,
                type: 'circle',
                source: srcId,
                paint: {
                    'circle-color': '#ff0000',
                    'circle-radius': 6,
                    'circle-stroke-width': 1,
                    'circle-stroke-color': '#ffffff'
                }
            });
        }

        // === Toggle Combined Panel ===
        const combinedPanel = document.getElementById("combined-panel");
        const panelContent = document.getElementById("panel-content");
        const panelToggle = document.getElementById("panel-toggle");

        panelToggle.addEventListener("click", () => {
            if (panelContent.style.display === "none") {
                panelContent.style.display = "flex";
                panelToggle.textContent = "Hide";
                if (shelterChart) shelterChart.resize();
                if (routeChartInstance) routeChartInstance.resize();
            } else {
                panelContent.style.display = "none";
                panelToggle.textContent = "Show";
            }
        });

        // Toggle Analysis logic
        els.analysisToggle.addEventListener("click", () => {
            analysisActive = !analysisActive;
            els.analysisToggle.setAttribute("aria-pressed", analysisActive ? "true" : "false");

            if (analysisActive) {
                switchAnalysisType(activeAnalysisType);
                if (activeAnalysisType === 'isoline') centerMarker.addTo(map);
            } else {
                centerMarker.remove();
                els.chartSection.style.display = "none";
                clearIsolines();
                clearRouteVisualization();
                clearRouteMarkers();
                // els.routeDirectionsWrapper.style.display = 'none'; // Tetap biarkan hidden/flex sesuai switchAnalysisType

                // Reset radio button ke Isoline
                els.isolineControls.style.display = 'flex';
                els.analysisTypeInputs[0].checked = true;
                activeAnalysisType = 'isoline';
                els.footerNote.textContent = "Tip: click on the map to set a new center point."; // Reset footer note

                // Update Legenda saat nonaktif
                els.legendItems.innerHTML = "";
                renderBaseLegendItems(false);
                updateShelterLayerVisibility();
            }
        });

        // =================================================================
        // UPDATE CHART
        // =================================================================
        function updateChart(data, colors) {
            const ranges = Object.keys(data);
            const counts = Object.values(data);
            const chartColors = ranges.map(r => colors[r]);

            const cssTextColor = (getComputedStyle(document.documentElement).getPropertyValue('--text') || '#e5e7eb').trim();

            if (shelterChart) {
                shelterChart.destroy();
                shelterChart = null;
            }

            Chart.defaults.font.family = 'system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", Helvetica, Arial';
            Chart.defaults.color = 'var(--text)';

            const ctx = els.shelterChart.getContext('2d');
            shelterChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ranges,
                    datasets: [{
                        label: 'Shelter Coverage',
                        data: counts,
                        backgroundColor: chartColors,
                        borderColor: chartColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    aspectRatio: 1.33,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: cssTextColor,
                                callback: function (value) { if (value % 1 === 0) { return value; } }
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            }
                        },
                        x: {
                            ticks: { color: cssTextColor },
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: true }
                    }
                }
            });
        }

        // =================================================================
        // getIsoline
        // =================================================================
        async function getIsoline() {
            if (!analysisActive || activeAnalysisType !== 'isoline') {
                clearIsolines();
                currentIsolineData = null;
                els.legendItems.innerHTML = "";
                renderBaseLegendItems(false);
                updateShelterLayerVisibility();
                return;
            }

            if (!isolineData.ranges || isolineData.ranges.size === 0) {
                alert("Please choose at least one range.");
                return;
            }

            // Konversi untuk API: time -> seconds; distance -> meters
            const apiRanges =
                isolineData.type === "time"
                    ? [...isolineData.ranges].map((m) => m * 60)
                    : [...isolineData.ranges].map((m) => m * 1000);

            clearIsolines();

            try {
                const rangesParam = apiRanges.join(",");
                const data = await fetchIsoline(
                    isolineData.lat,
                    isolineData.lon,
                    isolineData.type,
                    isolineData.mode,
                    rangesParam
                );
                currentIsolineData = data;

                const srcId = "isoline-multi";
                if (map.getSource(srcId)) map.removeSource(srcId);
                map.addSource(srcId, { type: "geojson", data });

                ensureShelterLayers();

                const ordered = [...apiRanges].sort((a, b) => b - a);
                els.legendItems.innerHTML = "";

                // Render Base Legend (Shelter) dan Reachable Shelters (true)
                renderBaseLegendItems(true);
                updateShelterLayerVisibility();

                const isolineColors = {};

                ordered.forEach((range, i) => {
                    const color = colorForIndex(i, ordered.length);
                    const fillId = `isoline-fill-${range}`;
                    const lineId = `isoline-line-${range}`;
                    const filterExpr = ["==", ["get", "range"], range];

                    if (map.getLayer(fillId)) map.removeLayer(fillId);
                    if (map.getLayer(lineId)) map.removeLayer(lineId);

                    map.addLayer({
                        id: fillId,
                        type: "fill",
                        source: srcId,
                        paint: { "fill-color": color, "fill-opacity": 0.25 },
                        filter: filterExpr
                    }, 'all-shelters-bg');

                    map.addLayer({
                        id: lineId,
                        type: "line",
                        source: srcId,
                        paint: { "line-color": color, "line-width": 2 },
                        filter: filterExpr
                    });

                    const unit = isolineData.type === 'time' ? 'min' : 'km';
                    const label = isolineData.type === "time" ? `${Math.round(range / 60)} ${unit}` : `${Math.round(range / 1000)} ${unit}`;
                    addLegendItem(label, color);

                    isolineColors[label] = color;
                });

                fitToGeoJSON(data);

                analyzeShelters(data, isolineColors);

            } catch (err) {
                console.error("Isoline fetch error:", err);
                els.legendItems.innerHTML = "Failed to fetch data.";
                renderBaseLegendItems(analysisActive && activeAnalysisType === 'isoline');
                updateShelterLayerVisibility();
            }
        }

        // Helper untuk memastikan layer shelter ada
        function ensureShelterLayers() {
            if (!map.getSource('all-shelters')) {
                map.addSource('all-shelters', { type: 'geojson', data: shelterPoints });
            } else {
                map.getSource('all-shelters').setData(shelterPoints);
            }

            if (!map.getLayer('all-shelters-bg')) {
                map.addLayer({
                    id: 'all-shelters-bg',
                    type: 'circle',
                    source: 'all-shelters',
                    paint: {
                        'circle-color': '#4a4a4a',
                        'circle-radius': 6,
                        'circle-stroke-width': 1,
                        'circle-stroke-color': '#ffffff'
                    }
                });
            }
        }

        // Route Layer Logic
        function addRouteLayer() {
            if (!map.getSource('network-route-source')) {
                map.addSource('network-route-source', {
                    type: 'geojson',
                    data: { type: 'FeatureCollection', features: [] }
                });
                map.addLayer({
                    id: 'network-route-layer',
                    type: 'line',
                    source: 'network-route-source',
                    layout: {
                        'line-join': 'round',
                        'line-cap': 'round'
                    },
                    paint: {
                        'line-color': '#60a5fa', // Warna Rute
                        'line-width': 6,
                        'line-opacity': 0.8
                    }
                });
            }
        }


        map.once("load", () => {
            ensureShelterLayers();
            addRouteLayer();
            renderBaseLegendItems(false);
            updateShelterLayerVisibility();
        });


        // Basemap switcher setup
        const switcherContainer = document.getElementById("basemapSwitcher");
        const activeLabel = document.getElementById("activeBasemap");
        const optionsContainer = document.getElementById("optionsContainer");

        Object.keys(basemaps).forEach((name) => {
            const option = document.createElement("div");
            option.textContent = name;

            option.addEventListener("click", () => {
                if (name !== activeBasemap) {
                    activeBasemap = name;
                    activeLabel.textContent = name;
                    map.setStyle(basemaps[name]);

                    // ---Navbar Color Adjustment ---
                    const isDark = name === "Dark";
                    if (isDark) {
                        document.body.classList.add("dark-basemap");
                    } else {
                        document.body.classList.remove("dark-basemap");
                    } // ---Navbar Color Adjustment ---

                    map.once("styledata", () => {
                        ensureShelterLayers();
                        addRouteLayer();
                        els.legendItems.innerHTML = "";

                        // LOGIC UPDATE LEGEND
                        if (activeAnalysisType === 'isoline') {
                            renderBaseLegendItems(analysisActive);
                            if (analysisActive) getIsoline();
                            if (analysisActive) centerMarker.addTo(map);
                        } else if (activeAnalysisType === 'network') {
                            renderBaseLegendItems(false);
                            renderRouteLegendItems(analysisActive);
                        } else {
                            renderBaseLegendItems(false);
                        }
                        updateShelterLayerVisibility();

                    });
                }
                optionsContainer.classList.remove("show");
            });

            optionsContainer.appendChild(option);
        });

        activeLabel.addEventListener("click", (e) => {
            e.stopPropagation();
            optionsContainer.classList.toggle("show");
        });

        document.addEventListener("click", (e) => {
            if (!switcherContainer.contains(e.target)) {
                optionsContainer.classList.remove("show");
            }
        });
    </script>
</body>

</html>